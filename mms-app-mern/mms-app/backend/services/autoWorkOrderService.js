// backend/services/autoWorkOrderService.js
const cron = require('node-cron');
const Equipment = require('../models/Equipment');
const AutoWorkOrderRule = require('../models/AutoWorkOrderRule');
const WorkOrder = require('../models/WorkOrder');
const Backlog = require('../models/Backlog');
const { getIO } = require('./websocketService');

// Check and generate auto work orders
const checkAutoWorkOrders = async () => {
  try {
    console.log('Checking for auto work order generation...');
    
    const activeRules = await AutoWorkOrderRule.find({ 
      isActive: true, 
      isDeleted: false 
    }).populate('equipment');

    for (const rule of activeRules) {
      if (!rule.equipment) continue;

      const shouldTrigger = await rule.shouldTrigger(rule.equipment);
      
      if (shouldTrigger) {
        // Generate work order
        const count = await WorkOrder.countDocuments();
        const woCode = `WO-AUTO-${String(count + 1).padStart(6, '0')}`;
        
        const workOrder = await WorkOrder.create({
          code: woCode,
          title: rule.workOrderTemplate.title,
          description: rule.workOrderTemplate.description,
          equipment: rule.equipment._id,
          status: 'Scheduled',
          priority: rule.priority || 'P2',
          type: rule.workOrderTemplate.type || 'Preventive',
          woType: 'Auto Generated',
          assignedTo: rule.equipment.ownership?.mechanical || null,
          scheduledDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
          estimatedHours: rule.workOrderTemplate.estimatedHours,
          estimatedCost: rule.workOrderTemplate.materials?.reduce((sum, mat) => 
            sum + (mat.quantity * mat.unitCost), 0) || 0,
          triggerCondition: {
            type: rule.triggerType,
            threshold: rule.triggerValue,
            currentValue: rule.triggerType === 'running_hours' 
              ? rule.equipment.runningHours - (rule.equipment.lastMaintenanceHours || 0)
              : null,
            description: `${rule.name} - Auto generated at ${rule.triggerValue} ${rule.triggerUnit}`
          },
          materials: rule.workOrderTemplate.materials || [],
          autoGenerationRule: rule._id,
          createdBy: rule.createdBy // Use rule creator as work order creator
        });

        // Update rule
        rule.lastTriggered = new Date();
        await rule.save();

        // Emit socket event
        const io = getIO();
        if (io) {
          io.emit('workorder:autoGenerated', workOrder);
        }

        console.log(`Auto work order ${woCode} generated for ${rule.equipment.name}`);
      }
    }
  } catch (error) {
    console.error('Error in auto work order generation:', error);
  }
};

// Generate backlogs from conditions
const generateConditionBasedBacklogs = async () => {
  try {
    const equipment = await Equipment.find({ 
      isDeleted: false, 
      status: 'Active' 
    });

    for (const eq of equipment) {
      // Check running hours threshold
      if (eq.runningHours >= eq.nextMaintenanceHours) {
        const existingBacklog = await Backlog.findOne({
          equipment: eq._id,
          source: 'Running Hours Alert',
          status: { $nin: ['Completed', 'Cancelled'] }
        });

        if (!existingBacklog) {
          const count = await Backlog.countDocuments();
          const backlog = await Backlog.create({
            code: `BL-AUTO-${String(count + 1).padStart(6, '0')}`,
            equipment: eq._id,
            issue: `Scheduled maintenance required after ${eq.nextMaintenanceHours} running hours`,
            category: 'Preventive',
            priority: eq.criticality === 'A' ? 'P1' : 'P2',
            status: 'Validated',
            dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 1 week
            estimatedHours: 4,
            estimatedCost: 10000,
            autoGenerated: true,
            source: 'Running Hours Alert',
            createdBy: eq.createdBy
          });

          // Emit socket event
          const io = getIO();
          if (io) {
            io.emit('backlog:autoGenerated', backlog);
          }
        }
      }

      // Check health score threshold
      if (eq.healthScore < 70) {
        const existingBacklog = await Backlog.findOne({
          equipment: eq._id,
          source: 'System Alert',
          issue: { $regex: 'health score', $options: 'i' },
          status: { $nin: ['Completed', 'Cancelled'] }
        });

        if (!existingBacklog) {
          const count = await Backlog.countDocuments();
          const backlog = await Backlog.create({
            code: `BL-AUTO-${String(count + 1).padStart(6, '0')}`,
            equipment: eq._id,
            issue: `Equipment health score below threshold (${eq.healthScore}%)`,
            category: 'Operational',
            priority: eq.healthScore < 50 ? 'P1' : 'P2',
            status: 'Open',
            dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3 days
            estimatedHours: 2,
            estimatedCost: 5000,
            autoGenerated: true,
            source: 'System Alert',
            createdBy: eq.createdBy
          });

          // Emit socket event
          const io = getIO();
          if (io) {
            io.emit('backlog:autoGenerated', backlog);
          }
        }
      }
    }
  } catch (error) {
    console.error('Error generating condition-based backlogs:', error);
  }
};

// Start the auto work order job
const startAutoWorkOrderJob = () => {
  // Run every hour
  cron.schedule('0 * * * *', async () => {
    await checkAutoWorkOrders();
    await generateConditionBasedBacklogs();
  });

  // Run on startup
  setTimeout(async () => {
    await checkAutoWorkOrders();
    await generateConditionBasedBacklogs();
  }, 5000);

  console.log('Auto work order service started');
};

module.exports = {
  startAutoWorkOrderJob,
  checkAutoWorkOrders,
  generateConditionBasedBacklogs
};
